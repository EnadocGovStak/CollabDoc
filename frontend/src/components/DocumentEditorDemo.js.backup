import React, { forwardRef, useImperativeHandle, useState, useEffect, useRef } from 'react';
import {
  DocumentEditorContainerComponent,
  DocumentEditorContainer,
  Toolbar,
} from '@syncfusion/ej2-react-documenteditor';
import '../utils/syncfusionModules'; // Import centralized module injection
import DocumentEditorErrorBoundary from './DocumentEditorErrorBoundary';

// Minimal document structure for initialization
const MINIMAL_DOCUMENT = {
  "sections": [{
    "sectionFormat": {
      "pageWidth": 612,
      "pageHeight": 792,
      "leftMargin": 72,
      "rightMargin": 72,
      "topMargin": 72,
      "bottomMargin": 72,
      "differentFirstPage": false,
      "differentOddAndEvenPages": false
    },
    "blocks": [{
      "paragraphFormat": {
        "styleName": "Normal",
        "listFormat": {}
      },
      "characterFormat": {
        "fontSize": 11,
        "fontFamily": "Calibri",
        "fontColor": "#000000"
      },
      "inlines": [{
        "characterFormat": {
          "fontSize": 11,
          "fontFamily": "Calibri",
          "fontColor": "#000000"
        },
        "text": " "
      }]
    }]
  }],
  "characterFormat": {
    "fontSize": 11,
    "fontFamily": "Calibri",
    "fontColor": "#000000"
  },
  "paragraphFormat": {
    "styleName": "Normal",
    "listFormat": {}
  },
  "styles": [
    {
      "name": "Normal",
      "type": "Paragraph",
      "paragraphFormat": {
        "listFormat": {}
      },
      "characterFormat": {
        "fontSize": 11,
        "fontFamily": "Calibri",
        "fontColor": "#000000"
      }
    }
  ]
};

const DocumentEditorDemo = forwardRef(({ initialContent, document, onContentChange, onDocumentLoaded, isReadOnly, serviceUrl }, ref) => {
  const container = useRef(null);
  const [isReady, setIsReady] = useState(false);

  // Expose methods to parent components
  useImperativeHandle(ref, () => ({
    getContent: () => {
      if (container.current?.documentEditor) {
        return container.current.documentEditor.serialize();
      }
      return null;
    },
    loadContent: (content) => {
      if (container.current?.documentEditor && content) {
        try {
          if (typeof content === 'string') {
            container.current.documentEditor.open(content);
          } else {
            container.current.documentEditor.open(JSON.stringify(content));
          }
        } catch (error) {
          console.error('Error loading content:', error);
        }
      }
    },
    setReadOnly: (readOnly) => {
      if (container.current?.documentEditor) {
        container.current.documentEditor.isReadOnly = readOnly;
      }
    },
    editor: container.current?.documentEditor
  }));

  // Standard Syncfusion initialization following DocEditorStandard pattern
  useEffect(() => {
    const timer = setTimeout(() => {
      if (container.current?.documentEditor) {
        setIsReady(true);
        
        // Set read-only mode
        if (isReadOnly) {
          container.current.documentEditor.isReadOnly = true;
        }

        // Load content if provided
        const contentToLoad = document?.content || initialContent;
        if (contentToLoad) {
          try {
            if (typeof contentToLoad === 'string') {
              const parsed = JSON.parse(contentToLoad);
              if (parsed.sections || parsed.sec || parsed.optimizeSfdt) {
                container.current.documentEditor.open(contentToLoad);
              } else {
                container.current.documentEditor.open(JSON.stringify(MINIMAL_DOCUMENT));
              }
            } else if (contentToLoad.sections || contentToLoad.sec || contentToLoad.optimizeSfdt) {
              container.current.documentEditor.open(JSON.stringify(contentToLoad));
            } else {
              container.current.documentEditor.open(JSON.stringify(MINIMAL_DOCUMENT));
            }
          } catch (error) {
            console.error('Error loading document content:', error);
            container.current.documentEditor.open(JSON.stringify(MINIMAL_DOCUMENT));
          }
        } else {
          // Load minimal document as default
          container.current.documentEditor.open(JSON.stringify(MINIMAL_DOCUMENT));
        }

        // Call onDocumentLoaded callback
        if (onDocumentLoaded) {
          onDocumentLoaded();
        }
      }
    }, 200); // Standard delay matching DocEditorStandard

    return () => clearTimeout(timer);
  }, [document, initialContent, isReadOnly, onDocumentLoaded]);

  // Handle content changes
  const handleContentChange = () => {
    if (container.current?.documentEditor && onContentChange) {
      try {
        const content = container.current.documentEditor.serialize();
        onContentChange(content);
      } catch (error) {
        console.error('Error getting content for change callback:', error);
      }
    }
  };

  return (
    <DocumentEditorErrorBoundary>
      <DocumentEditorContainerComponent
        ref={container}
        height="100%"
        enableToolbar={true}
        serviceUrl={serviceUrl}
        contentChange={handleContentChange}
        created={() => {
          // Component created callback - standard Syncfusion pattern
          console.log('DocumentEditorComponent created');
        }}
      />
    </DocumentEditorErrorBoundary>
  );
});

DocumentEditorDemo.displayName = 'DocumentEditorDemo';

export default DocumentEditorDemo;
  SfdtExport,
  Selection,
  Editor,
  EditorHistory,
  WordExport,
  TextExport,
  HyperlinkDialog,
  TableDialog,
  BookmarkDialog,
  TableOfContentsDialog,
  PageSetupDialog,
  StyleDialog,
  ListDialog,
  ParagraphDialog,
  BulletsAndNumberingDialog,
  FontDialog,
  TablePropertiesDialog,
  BordersAndShadingDialog,
  TableOptionsDialog,
  CellOptionsDialog,
  StylesDialog,
  ImageResizer,
  ContextMenu,
  Print
} from '@syncfusion/ej2-react-documenteditor';
import { registerLicense } from '@syncfusion/ej2-base';
import DocumentEditorErrorBoundary from './DocumentEditorErrorBoundary';
import './DocumentEditor.css';

// Note: Modules are now injected globally in utils/syncfusionModules.js

// A more complete minimal valid SFDT document to prevent selection/caret errors
const MINIMAL_DOCUMENT = {
  "sections": [{
    "sectionFormat": {
      "pageWidth": 612,
      "pageHeight": 792,
      "leftMargin": 72,
      "rightMargin": 72,
      "topMargin": 72,
      "bottomMargin": 72,
      "differentFirstPage": false,
      "differentOddAndEvenPages": false,
      "headerDistance": 36,
      "footerDistance": 36
    },
    "blocks": [{
      "paragraphFormat": {
        "styleName": "Normal",
        "listFormat": {}
      },
      "characterFormat": {
        "fontSize": 11,
        "fontFamily": "Calibri",
        "fontColor": "#000000"
      },
      "inlines": [{
        "characterFormat": {
          "fontSize": 11,
          "fontFamily": "Calibri",
          "fontColor": "#000000"
        },
        "text": " "
      }]
    }]
  }],
  "characterFormat": {
    "fontSize": 11,
    "fontFamily": "Calibri",
    "fontColor": "#000000"
  },
  "paragraphFormat": {
    "styleName": "Normal",
    "listFormat": {}
  },
  "styles": [
    {
      "name": "Normal",
      "type": "Paragraph",
      "paragraphFormat": {
        "listFormat": {}
      },
      "characterFormat": {
        "fontSize": 11,
        "fontFamily": "Calibri",
        "fontColor": "#000000"
      }
    }
  ]
};

const DocumentEditorDemo = forwardRef(({ initialContent, document, onContentChange, documentSettings, onDocumentLoaded, isReadOnly, serviceUrl }, ref) => {
  const editorInstance = useRef(null);
  const [isEditorReady, setIsEditorReady] = useState(false);
  const debounceTimeout = useRef(null);
  const timersRef = useRef([]);
  const resizeHandlerRef = useRef(null);
  const initializationInProgress = useRef(false);
  const componentMountedRef = useRef(true);
  
  // Debounced content change handler
  const debouncedContentChange = useRef((content) => {
    if (debounceTimeout.current) {
      clearTimeout(debounceTimeout.current);
    }
    debounceTimeout.current = setTimeout(() => {
      if (onContentChange) {
        onContentChange(content);
      }
    }, 1000); // Debounce for 1 second
  }).current;
  
  // Custom function to handle resize safely
  const handleSafeResize = () => {
    try {
      if (editorInstance.current?.documentEditor && 
          !editorInstance.current.documentEditor.isDestroyed &&
          editorInstance.current.documentEditor.documentHelper &&
          editorInstance.current.documentEditor.documentHelper.pages &&
          editorInstance.current.documentEditor.documentHelper.pages.length > 0) {
        editorInstance.current.documentEditor.resize();
      }
    } catch (error) {
      console.warn("Error during editor resize:", error);
    }
  };
  
  // Effect for cleanup
  useEffect(() => {
    componentMountedRef.current = true;
    
    // Function to clear all timers
    const clearAllTimers = () => {
      timersRef.current.forEach(timer => clearTimeout(timer));
      timersRef.current = [];
    };
    
    return () => {
      componentMountedRef.current = false;
      initializationInProgress.current = false;
      
      // Clear all timers
      clearAllTimers();
      
      // Clear debounce timeout
      if (debounceTimeout.current) {
        clearTimeout(debounceTimeout.current);
      }
      
      // Remove resize handler
      if (resizeHandlerRef.current) {
        window.removeEventListener('resize', resizeHandlerRef.current);
        resizeHandlerRef.current = null;
      }
      
      const editor = editorInstance.current?.documentEditor;
      if (editor && !editor.isDestroyed) {
        try {
          if (editor.selection) editor.selection.destroy();
          if (editor.editor) editor.editor.destroy();
          editor.destroy();
        } catch (error) {
          console.warn('Error during editor cleanup:', error);
        }
      }
    };
  }, []);

  // Expose editor methods via ref
  useImperativeHandle(ref, () => ({
    editor: editorInstance.current?.documentEditor,
    getContent: async () => {
      if (editorInstance.current?.documentEditor) {
        try {
          const editor = editorInstance.current.documentEditor;
          // Use the correct Syncfusion API method
          if (typeof editor.serialize === 'function') {
            return editor.serialize();
          } else if (typeof editor.sfdt === 'string') {
            return editor.sfdt;
          } else {
            console.warn("Could not find serialize method or sfdt property");
            return null;
          }
        } catch (error) {
          console.error("Error getting content:", error);
          return null;
        }
      }
      return null;
    },
    loadContent: (contentToLoad) => {
      if (!componentMountedRef.current) {
        console.error("Cannot load content: component is unmounted");
        return;
      }
      
      if (editorInstance.current?.documentEditor && isEditorReady) {
        try {
          const editor = editorInstance.current.documentEditor;
          
          // Check if editor is initialized
          if (editor.isDestroyed) {
            console.error("Cannot load content: editor is destroyed");
            return;
          }
          
          // Make sure modules are initialized
          if (editor.selection && !editor.selection.isInitialized) {
            editor.selection.initSelectionModule();
          }
          
          console.log("Loading content via loadContent method, type:", typeof contentToLoad);
          
          if (typeof contentToLoad === 'string') {
            if (contentToLoad === '') {
              editor.open(JSON.stringify(MINIMAL_DOCUMENT));
            } else {
              // Try to parse and check if it's SFDT content
              try {
                const parsedContent = JSON.parse(contentToLoad);
                if (parsedContent.sections || parsedContent.sec || parsedContent.optimizeSfdt) {
                  // Direct SFDT content
                  editor.open(contentToLoad);
                  console.log("Loaded direct SFDT via loadContent (string)", parsedContent.optimizeSfdt ? "(optimized)" : "(standard)");
                } else {
                  // Wrap it
                  editor.open(JSON.stringify({ "sfdt": contentToLoad }));
                  console.log("Loaded wrapped content via loadContent");
                }
              } catch (parseError) {
                // Not JSON - treat as plain text
                editor.open(JSON.stringify({
                  "sections": [{
                    "blocks": [{
                      "paragraphFormat": { "styleName": "Normal" },
                      "inlines": [{ "text": contentToLoad }]
                    }]
                  }]
                }));
              }
            }
          } else if (typeof contentToLoad === 'object' && contentToLoad !== null) {
            if (contentToLoad.sections || contentToLoad.sec || contentToLoad.optimizeSfdt) {
              // Direct SFDT content
              editor.open(JSON.stringify(contentToLoad));
              console.log("Loaded direct SFDT via loadContent (object)", contentToLoad.optimizeSfdt ? "(optimized)" : "(standard)");
            } else {
              // Wrap it
              editor.open(JSON.stringify({ "sfdt": JSON.stringify(contentToLoad) }));
              console.log("Loaded wrapped content via loadContent (object)");
            }
          } else {
            editor.open(JSON.stringify(MINIMAL_DOCUMENT));
          }
        } catch (error) {
          console.error("Error loading content:", error);
          if (componentMountedRef.current && editorInstance.current?.documentEditor && !editorInstance.current.documentEditor.isDestroyed) {
            try {
              editorInstance.current.documentEditor.open(JSON.stringify(MINIMAL_DOCUMENT));
            } catch (fallbackError) {
              console.error("Error loading fallback content:", fallbackError);
            }
          }
        }
      }
    },
    setReadOnly: (readOnlyStatus) => {
      if (editorInstance.current?.documentEditor) {
        editorInstance.current.documentEditor.isReadOnly = readOnlyStatus;
      }
    }
  }));

  // Effect for editor initialization and content loading
  useEffect(() => {
    // Prevent multiple simultaneous initialization attempts
    if (initializationInProgress.current) {
      console.log("Initialization already in progress, skipping");
      return;
    }
    
    // Don't initialize if component is unmounted
    if (!componentMountedRef.current) {
      console.log("Component unmounted, skipping initialization");
      return;
    }
    
    // Function to clear all timers
    const clearAllTimers = () => {
      timersRef.current.forEach(timer => clearTimeout(timer));
      timersRef.current = [];
    };
    
    console.log("DocumentEditorDemo useEffect triggered");
    console.log("- isEditorReady:", isEditorReady);
    console.log("- document prop:", document);
    console.log("- initialContent prop:", initialContent);
    console.log("- isReadOnly:", isReadOnly);
    
    const initializeEditor = async () => {
      // Set initialization flag
      initializationInProgress.current = true;
      
      try {
        // More comprehensive readiness check
        if (!editorInstance.current) {
          console.log("Editor instance not available");
          return;
        }
        
        if (!isEditorReady) {
          console.log("Editor not marked as ready");
          return;
        }
        
        // Check if component is still mounted
        if (!componentMountedRef.current) {
          console.log("Component unmounted during initialization");
          return;
        }
        
        // Wait for documentEditor to be available
        let attempts = 0;
        const maxAttempts = 15;
        while (!editorInstance.current.documentEditor && attempts < maxAttempts && componentMountedRef.current) {
          console.log(`Waiting for documentEditor, attempt ${attempts + 1}/${maxAttempts}`);
          await new Promise(resolve => setTimeout(resolve, 100));
          attempts++;
        }
        
        if (!editorInstance.current.documentEditor) {
          console.warn("DocumentEditor not available after waiting");
          return;
        }
        
        // Check if component is still mounted after waiting
        if (!componentMountedRef.current) {
          console.log("Component unmounted while waiting for documentEditor");
          return;
        }
        
        const editor = editorInstance.current.documentEditor;
        
        // Check if editor is destroyed before proceeding
        if (editor.isDestroyed) {
          console.warn('Editor is destroyed, cannot initialize');
          return;
        }
        
        console.log("Editor is ready, proceeding with initialization");
        
        // Set read-only state
        editor.isReadOnly = !!isReadOnly;
        
        console.log("Initializing editor modules");
        
        // Initialize selection module first with safety checks
        if (editor.selection && componentMountedRef.current) {
          try {
            if (typeof editor.selection.initSelectionModule === 'function') {
              console.log("Initializing selection module");
              editor.selection.initSelectionModule();
            } else {
              console.log("Selection module already initialized or method unavailable");
            }
          } catch (selectionError) {
            console.warn("Error initializing selection module:", selectionError);
          }
        }
        
        // Initialize editor module with safety checks
        if (editor.editor && componentMountedRef.current) {
          try {
            if (typeof editor.editor.initEditor === 'function') {
              console.log("Initializing editor module");
              editor.editor.initEditor();
            } else {
              console.log("Editor module already initialized or method unavailable");
            }
          } catch (editorError) {
            console.warn("Error initializing editor module:", editorError);
          }
        }
        
        // Check component mount status before loading content
        if (!componentMountedRef.current) {
          console.log("Component unmounted during module initialization");
          return;
        }
        
        // Load content with a delay to ensure initialization is complete
        const loadTimer = setTimeout(() => {
          try {
            // Triple-check everything is still valid
            if (!componentMountedRef.current) {
              console.log("Component unmounted before content loading");
              return;
            }
            
            if (!editorInstance.current?.documentEditor || editorInstance.current.documentEditor.isDestroyed) {
              console.warn("Editor no longer available for content loading");
              return;
            }
            
            const editor = editorInstance.current.documentEditor;
            console.log("Loading content");
            
            // Determine what content to load (prioritize document.content, then initialContent)
            let contentToLoad = null;
            if (document && document.content) {
              contentToLoad = document.content;
              console.log("Loading content from document prop, content type:", typeof contentToLoad);
              console.log("Content preview:", typeof contentToLoad === 'string' ? contentToLoad.substring(0, 100) + '...' : contentToLoad);
            } else if (initialContent) {
              contentToLoad = initialContent;
              console.log("Loading content from initialContent prop");
            }
            
            // Load the content
            if (!contentToLoad) {
              editor.open(JSON.stringify(MINIMAL_DOCUMENT));
              console.log("Loaded minimal document");
            } else if (typeof contentToLoad === 'string') {
              // Try to parse if it's a JSON string
              try {
                const parsedContent = JSON.parse(contentToLoad);
                
                // Check if this is SFDT content (standard or optimized format)
                if (parsedContent.sections || parsedContent.sec || parsedContent.optimizeSfdt) {
                  // This is direct SFDT content - use it as is
                  editor.open(contentToLoad);
                  console.log("Loaded direct SFDT content (string)", parsedContent.optimizeSfdt ? "(optimized)" : "(standard)");
                } else {
                  // Wrap in proper SFDT structure
                  editor.open(JSON.stringify({ "sfdt": contentToLoad }));
                  console.log("Loaded wrapped SFDT content");
                }
              } catch (parseError) {
                // If parsing fails, treat as plain text
                console.log("Content is not JSON, treating as plain text");
                editor.open(JSON.stringify({
                  "sections": [{
                    "blocks": [{
                      "paragraphFormat": { "styleName": "Normal" },
                      "inlines": [{ "text": contentToLoad }]
                    }]
                  }]
                }));
              }
            } else if (typeof contentToLoad === 'object' && contentToLoad !== null) {
              // Check if this is SFDT content (standard or optimized format)
              if (contentToLoad.sections || contentToLoad.sec || contentToLoad.optimizeSfdt) {
                // This is direct SFDT content - stringify and use
                editor.open(JSON.stringify(contentToLoad));
                console.log("Loaded direct SFDT content (object)", contentToLoad.optimizeSfdt ? "(optimized)" : "(standard)");
              } else {
                // Wrap in proper SFDT structure
                editor.open(JSON.stringify({ "sfdt": JSON.stringify(contentToLoad) }));
                console.log("Loaded wrapped SFDT content from object");
              }
            } else {
              editor.open(JSON.stringify(MINIMAL_DOCUMENT));
              console.log("Loaded default minimal document");
            }
            
            // Set up resize handler after document is loaded - but only if component is still mounted
            if (componentMountedRef.current) {
              const resizeTimer = setTimeout(() => {
                if (componentMountedRef.current) {
                  if (resizeHandlerRef.current) {
                    window.removeEventListener('resize', resizeHandlerRef.current);
                  }
                  resizeHandlerRef.current = handleSafeResize;
                  window.addEventListener('resize', resizeHandlerRef.current);
                }
              }, 200);
              
              timersRef.current.push(resizeTimer);
            }
          } catch (loadError) {
            console.error("Error loading document:", loadError);
            if (componentMountedRef.current && editorInstance.current?.documentEditor && !editorInstance.current.documentEditor.isDestroyed) {
              try {
                editorInstance.current.documentEditor.open(JSON.stringify(MINIMAL_DOCUMENT));
              } catch (fallbackError) {
                console.error("Error loading fallback content:", fallbackError);
              }
            }
          }
        }, 300);
        
        timersRef.current.push(loadTimer);
        
      } catch (error) {
        console.error("Error during editor initialization:", error);
        if (componentMountedRef.current) {
          const editor = editorInstance.current?.documentEditor;
          if (editor && !editor.isDestroyed) {
            try {
              editor.open(JSON.stringify(MINIMAL_DOCUMENT));
            } catch (fallbackError) {
              console.error("Error loading fallback content:", fallbackError);
            }
          }
        }
      } finally {
        // Clear initialization flag
        initializationInProgress.current = false;
      }
    };
    
    const initTimer = setTimeout(() => {
      if (componentMountedRef.current) {
        initializeEditor();
      }
    }, 100);
    
    timersRef.current.push(initTimer);
    
    return clearAllTimers;
  }, [initialContent, document, isEditorReady, isReadOnly]);

  return (
    <DocumentEditorErrorBoundary>
      <div className="document-editor-container" style={{ height: '100%', width: '100%' }}>
        <DocumentEditorContainerComponent
          id="doc_editor_container"
          ref={editorInstance}
          style={{ display: 'block', height: '100%' }}
          enableToolbar={true}
          enableSelection={true}
          enableEditor={true}
          enableEditorHistory={true}
          enableContextMenu={true}
          enableSearch={true}
          enableOptionsPane={true}
          enableBookmarkDialog={true}
          enableBordersAndShadingDialog={true}
          enableFontDialog={true}
          enableTableDialog={true}
          enableParagraphDialog={true}
          enableHyperlinkDialog={true}
          enableImageResizer={true}
          enableListDialog={true}
          enablePageSetupDialog={true}
          enableSfdtExport={true}
          enableStyleDialog={true}
          enableTableOfContentsDialog={true}
          enableTableOptionsDialog={true}
          enableTablePropertiesDialog={true}
          enableTextExport={true}
          enableWordExport={true}
          showPropertiesPane={false}
          serviceUrl={serviceUrl || 'https://ej2services.syncfusion.com/production/web-services/api/documenteditor/'}
          created={() => {
            console.log("DocumentEditorComponent created");
            
            // Use a small delay to ensure the component is fully mounted
            setTimeout(() => {
              // Check if component is still mounted
              if (!componentMountedRef.current) {
                console.log("Component unmounted during created callback");
                return;
              }
              
              // Additional safety check for selection initialization
              if (editorInstance.current?.documentEditor) {
                const editor = editorInstance.current.documentEditor;
                
                console.log("Editor available in created callback:", {
                  hasEditor: !!editor,
                  hasSelection: !!editor.selection,
                  hasEditorModule: !!editor.editor,
                  isDestroyed: editor.isDestroyed
                });
                
                // Ensure selection is properly initialized before any operations
                try {
                  if (editor.selection) {
                    console.log("Selection module available");
                  } else {
                    console.warn("Selection module not available");
                  }
                } catch (selectionError) {
                  console.warn("Error checking selection module:", selectionError);
                }
              }
              
              // Monkey patch DocumentEditorContainer prototype to fix protectionType error
              // This approach ensures all instances are patched at once
              try {
                const containerPrototype = Object.getPrototypeOf(editorInstance.current);
                if (containerPrototype && containerPrototype.showPropertiesPaneOnSelection) {
                  const originalMethod = containerPrototype.showPropertiesPaneOnSelection;
                  
                  // Only patch if not already patched
                  if (!containerPrototype._patchedShowPropertiesPane) {
                    containerPrototype.showPropertiesPaneOnSelection = function() {
                      try {
                        // Check all required properties before executing
                        if (this && this.documentEditor && 
                            this.documentEditor.selection && 
                            this.documentEditor.selection.sectionFormat &&
                            this.documentEditor.selection.characterFormat) {
                          return originalMethod.apply(this, arguments);
                        }
                      } catch (error) {
                        console.warn('Error in showPropertiesPaneOnSelection:', error);
                      }
                    };
                    
                    // Mark as patched to avoid double patching
                    containerPrototype._patchedShowPropertiesPane = true;
                    console.log("Successfully patched showPropertiesPaneOnSelection method");
                  }
                }
              } catch (error) {
                console.warn("Error patching showPropertiesPaneOnSelection:", error);
              }
              
              // Only set editor ready if component is still mounted
              if (componentMountedRef.current) {
                setIsEditorReady(true);
                
                if (onDocumentLoaded) {
                  onDocumentLoaded();
                }
              }
            }, 100); // Small delay to ensure proper initialization
          }}
          contentChange={() => {
            if (onContentChange && componentMountedRef.current && editorInstance.current?.documentEditor) {
              try {
                const editor = editorInstance.current.documentEditor;
                
                // Check if editor is still valid
                if (editor.isDestroyed) {
                  return;
                }
                
                let content = null;
                
                // Use the correct Syncfusion API method
                if (typeof editor.serialize === 'function') {
                  content = editor.serialize();
                } else if (typeof editor.sfdt === 'string') {
                  content = editor.sfdt;
                }
                
                if (content && componentMountedRef.current) {
                  debouncedContentChange(content);
                }
              } catch (error) {
                console.error('Error serializing content:', error);
              }
            }
          }}
          height="100%"
          width="100%"
          documentEditorSettings={{
            enableImageResizer: true,
            enableSelection: true,
            enableContextMenu: true,
            enableEditorHistory: true,
            enableTableDialog: true,
            enablePrint: true,
            enableWordExport: true,
            ...documentSettings
          }}
        />
      </div>
    </DocumentEditorErrorBoundary>
  );
});

DocumentEditorDemo.displayName = 'DocumentEditorDemo';

export default DocumentEditorDemo;
